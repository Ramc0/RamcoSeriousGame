<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Parallax 3d</title>

  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <script
    src="https://cdn.jsdelivr.net/gh/feiss/aframe-environment-component/dist/aframe-environment-component.min.js"></script>

  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: sans-serif;
      color: #eee;
    }

    #video {
      position: fixed;
      bottom: 10px;
      right: 10px;
      width: 220px;
      transform: scaleX(-1);
      opacity: 0.4;
      z-index: 10;
      border: 2px solid #444;
      border-radius: 4px;
    }

    #ui {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 20;
      background: rgba(0, 0, 0, 0.6);
      padding: 8px 10px;
      border-radius: 6px;
      border: 1px solid #555;
      font-size: 14px;
    }

    #parallaxRange {
      width: 150px;
      vertical-align: middle;
    }

    label {
      margin-right: 4px;
    }
  </style>
</head>

<body>
  <div id="ui">
    <label for="parallaxRange">Parallax:</label>
    <input id="parallaxRange" type="range" min="0" max="5" step="0.05" value="1" />
    <span id="parallaxValue">1.00</span>
  </div>

  <video id="video" autoplay playsinline></video>

  <a-scene
    renderer="antialias: true; colorManagement: true; physicallyCorrectLights: true; shadowMap.enabled: true; shadowMap.type: pcfsoft">
    <a-entity environment="
      preset: default;
      ground: flat;
      groundYScale: 1;
      groundTexture: none;
      groundColor: #303030;
      groundColor2: #404040;
      skyType: gradient;
      skyColor: #88ccee;
      horizonColor: #ffffff;
      lighting: none;
    "></a-entity>

    <a-plane position="0 0 0" rotation="-90 0 0" width="100" height="100" color="#404040" shadow="receive: true">
    </a-plane>

    <a-entity id="rig" position="0 1.6 0">
      <a-entity id="cam" camera look-controls="enabled: false"></a-entity>
    </a-entity>

    <a-entity id="sunTarget" position="0 0 0"></a-entity>

    <a-entity light="type: directional; intensity: 1.1; castShadow: true" position="4 8 6" target="#sunTarget">
    </a-entity>

    <a-entity light="type: ambient; intensity: 0.35; color: #ffffff"></a-entity>


    <a-sphere position="-2 0.5 -3" radius="0.5" color="#ff4444" shadow="cast: true; receive: true"></a-sphere>

    <a-box position="-0.8 0.4 -2.2" depth="0.6" height="0.6" width="0.6" color="#44ff44"
      shadow="cast: true; receive: true"></a-box>

    <a-cylinder position="0.6 0.5 -3.2" radius="0.3" height="1" color="#4444ff"
      shadow="cast: true; receive: true"></a-cylinder>

    <a-torus-knot position="1.8 0.9 -4" radius="0.6" radius-tubular="0.08" color="#ffcc00"
      shadow="cast: true; receive: true"></a-torus-knot>

    <a-dodecahedron position="3 0.7 -5" radius="0.5" color="#ff00aa"
      shadow="cast: true; receive: true"></a-dodecahedron>

    <a-octahedron position="-3 0.7 -4.5" radius="0.4" color="#00ffcc" shadow="cast: true; receive: true"></a-octahedron>

    <a-ring position="-1 0.01 -6" rotation="-90 0 0" radius-inner="0.3" radius-outer="0.6" color="#ffdddd"
      shadow="cast: true; receive: true"></a-ring>

    <a-cone position="1 0.9 -6.5" radius-bottom="0.5" radius-top="0.0" height="1.2" color="#ffddff"
      shadow="cast: true; receive: true"></a-cone>

    <a-torus position="0 0.8 -5.2" rotation="0 45 0" radius="0.7" radius-tubular="0.12" color="#88aaff"
      shadow="cast: true; receive: true"></a-torus>

    <a-sphere position="-1 0.2 -2.5" radius="0.12" color="#ffffff" shadow="cast: true; receive: true"></a-sphere>
    <a-sphere position="-0.5 0.2 -3.5" radius="0.12" color="#ffffff" shadow="cast: true; receive: true"></a-sphere>
    <a-sphere position="0 0.2 -4.5" radius="0.12" color="#ffffff" shadow="cast: true; receive: true"></a-sphere>
    <a-sphere position="0.5 0.2 -5.5" radius="0.12" color="#ffffff" shadow="cast: true; receive: true"></a-sphere>
    <a-sphere position="1 0.2 -6.5" radius="0.12" color="#ffffff" shadow="cast: true; receive: true"></a-sphere>
  </a-scene>

  <script type="module">
    import {
      FaceLandmarker,
      FilesetResolver
    } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/vision_bundle.js";

    const video = document.getElementById("video");
    const parallaxRange = document.getElementById("parallaxRange");
    const parallaxValue = document.getElementById("parallaxValue");
    const rigEl = document.getElementById("rig");

    let faceLandmarker = null;
    let running = false;
    let lastVideoTime = -1;
    let parallaxFactor = 1.0;

    const baseCam = { x: 0, y: 1.0, z: 0 };

    let baselineScale = null;

    parallaxRange.addEventListener("input", (e) => {
      parallaxFactor = parseFloat(e.target.value);
      parallaxValue.textContent = parallaxFactor.toFixed(2);
    });

    async function initCamera() {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { width: 640, height: 480 }
      });
      video.srcObject = stream;
      return new Promise(resolve => {
        video.onloadedmetadata = () => resolve();
      });
    }

    async function initFaceLandmarker() {
      const filesetResolver = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
      );

      faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
        baseOptions: {
          modelAssetPath:
            "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/latest/face_landmarker.task"
        },
        runningMode: "VIDEO",
        numFaces: 1
      });
    }

    function getHeadMetrics(landmarks) {
      if (!landmarks || !landmarks.length) return null;

      let sumX = 0;
      let sumY = 0;
      const n = landmarks.length;
      for (let i = 0; i < n; i++) {
        sumX += landmarks[i].x;
        sumY += landmarks[i].y;
      }
      const center = { x: sumX / n, y: sumY / n };

      let scale = 0.1;
      const leftIdx = 33;
      const rightIdx = 263;
      if (landmarks[leftIdx] && landmarks[rightIdx]) {
        const lx = landmarks[leftIdx].x;
        const ly = landmarks[leftIdx].y;
        const rx = landmarks[rightIdx].x;
        const ry = landmarks[rightIdx].y;
        scale = Math.hypot(rx - lx, ry - ly);
      }

      return { center, scale };
    }


    function mapHeadToCamera(center, scale) {
      const nx = center.x * 2 - 1;
      const ny = center.y * 2 - 1;

      const baseMaxX = 0.5;
      const baseMaxY = 0.3;

      const maxX = baseMaxX * parallaxFactor;
      const maxY = baseMaxY * parallaxFactor;

      const dx = -nx * maxX;

      const dy = -ny * maxY;

      if (scale && !baselineScale) baselineScale = scale;
      let dz = 0;
      if (scale && baselineScale) {
        let rel = scale / baselineScale;
        rel = Math.min(Math.max(rel, 0.7), 1.3);
        const delta = rel - 1.0;
        const maxDepthOffset = 0.8;
        dz = -delta * maxDepthOffset * parallaxFactor;
      }

      return {
        x: baseCam.x + dx,
        y: baseCam.y + dy,
        z: baseCam.z + dz
      };
    }

    function smooth(prev, next, factor) {
      if (!prev) return next;
      return {
        x: prev.x + (next.x - prev.x) * factor,
        y: prev.y + (next.y - prev.y) * factor,
        z: prev.z + (next.z - prev.z) * factor
      };
    }

    let smoothedCamPos = null;

    async function processVideoFrame() {
      if (!running) return;

      const nowMs = performance.now();
      const videoTime = video.currentTime;

      if (videoTime === lastVideoTime) {
        requestAnimationFrame(processVideoFrame);
        return;
      }
      lastVideoTime = videoTime;

      const results = faceLandmarker.detectForVideo(video, nowMs);

      if (results.faceLandmarks && results.faceLandmarks.length > 0) {
        const landmarks = results.faceLandmarks[0];
        const metrics = getHeadMetrics(landmarks);

        if (metrics) {
          const camPos = mapHeadToCamera(metrics.center, metrics.scale);
          smoothedCamPos = smooth(smoothedCamPos, camPos, 0.18);

          rigEl.setAttribute(
            "position",
            `${smoothedCamPos.x} ${smoothedCamPos.y} ${smoothedCamPos.z}`
          );
        }
      }

      requestAnimationFrame(processVideoFrame);
    }

    (async function start() {
      try {
        await initCamera();
        await initFaceLandmarker();
        running = true;
        processVideoFrame();
      } catch (e) {
        console.error("Error initializing:", e);
      }
    })();
  </script>
</body>

</html>